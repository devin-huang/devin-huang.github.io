---
layout:     post
title:     Vue开发
subtitle:   Vue2.0+
date:       2018-11-01
author:     BY Devin
header-img: img/post-bg-digital-native.jpg
catalog: true
tags:
    - vue
---

## 简介

vuex  : Vue组件中每個data变量，它就是一个状态，当应用程序足够庞大时，如果将这些状态集中管理就会非常方便，于是Vuex便应运而生

axios : src/utils/http.js 用于封装axios异步GET/POST/DELETE等方式获取数据

computed是计算属性，也就是依赖其它的属性计算所得出最后的值（自动侦听所依赖其它的属性改变而触发）

watch是去监听一个值的变化，然后执行相对应的函数（ 侦听指定值改变而触发 ）

* 注意：computed中无法获取到API的数据，唯有使用watch

基于实践开发项目sst-PO system初步搭建：

vue-cli + vuex + axios

`npm install -g vue-cli`

`npm install axios vuex`

## export default 和 export 区别

* export与export default均可用于导出常量、函数、文件、模块等 (export、import可以有多个，export default仅有一个)

* 通过export方式导出，在导入时要加{ }，export default则不需要

## VUEX

1-1 -> index.js : 全部API接口输出
1-2 -> 调用对应接口函数
2   -> action 调用成功/失败返回的参数与处理
3   -> 将action获取的数据按变量与函数对应整合
4   -> 定义变量存放API返回的数据

（不通过VUEX直接调用API方式：）


this.$forceUpdate()
this.$nextTick(() => {
    //变量赋值
})
this.$set(object,index,value); //object对象/数组，index索引，value：改成的值

## 自定义组件component

组件HTML调用

```
// 特别注意是ref如需循环必须添加唯一的ref;
<test ref="testForm" my-message="hello" :myObject="{name:'Devin'}" :isShow="true" > 
    <div slot="title">
        <button> BUTTON </button>
    </div>
    <div> OTHER </div>
</test>
```

* 组件引用 

```
<template>
    <div>
        <div class="main">
            <slot name="title"></slot> // slot插槽使用：通过name对应特定内容
            <slot></slot>              // slot插槽使用：放置内容（除去特定）
        </div>
    <div>
</template>

<script>
import Test from '@/components/test'
export default{

    components: { Test } ,
    name      : "test" ,
    // 父级数据通信到子级
    props:{                                               
        myMessage：{ type : String , default : ''     },  
        myObject : { type : Object , default : ()=>{} },  // 注意类型为数组/对象的默认值需要函数返回，否则报错
    },
    watch:{
        isShow(val){ }                                    // 侦听父组件isShow变化而触发，注意像myMessage如果是API数据是无法侦听变化
    }
    
}

</script>
```

* 父级/祖级/同级调用子级组件函数

```
this.$refa["testForm"].toXX();
```

* 子级数据通信到父级

```
this.$emit()     触发事件 : 相对于JS调用函数 => toEvent(object)
this.$on         绑定事件 : 相对于JS定义函数 => function toEvent(object){ ... } 

* 两个组件之间需要进行通信，但是它们彼此不是父子组件
var bus = new Vue();

bus.$emit('say-hello', 'world')                          // 在组件 A 的 methods 方法中触发事件

bus.$on('say-hello', function (arg) {                    // 在组件 B 的 created 钩子函数中监听事件
  console.log('hello ' + arg);          // hello world
})
```

## 自定义指令

尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。
自定义指令就是一种有效的补充和扩展，用于定义任何的DOM操作，并且是可复用的。

* INPUT自动获取焦点

```
export default {
  update: function (el,binding) {
    if(binding.value.isShowList) el.querySelector('input').focus();
  }
}
```

* 比如vue中使用jquery插件：

```
<table id="testTable">
  <tr v-for="(el, lineIndex) in lines" v-line-inserted="lineIndex" >
   <td> <input name="bindSelect2" /> <td>
  </tr>
</table>

function renderLines(el, lineIndex){
  $("testTable tr").eq(lineIndex).select2({...});
}
 
Vue.directive('line-inserted', {
  inserted: function (el, binding) {
   var lineIndex = binding.value;
   renderLines(el, lineIndex);
  }
});
```
   

## v-bind 动态绑定属性

属性绑定（当数据是从Controller中绑定到View时使用）： 

`v-bind: src /width/alt/class/style.....`  -> 简写： `:src/width/alt ...`

特殊属性class

方法1. `:class='[red,blue]'` -> 使用对应的Class集合 ; 

方法2. `:class='{ red:false , blue:true }'`;

特殊属性style

`:style='json'`( `json:{ color:'red',backgroundColor:'blue' }` json代表controller内的数据);

## Event

参考：https://cn.vuejs.org/v2/api/#v-on

事件简写 `v-on:click()`  ->  `@click()`

事件对象 `@mousemove='func($event)'`  ->  获取 `$event.clientX`与 `$event.clientY` (鼠标XY坐标)

事件冒泡 -> 阻止事件冒泡 -> JS原生：`$event.cancelBubble = true` ; -> Vue简写:`@click.stop='func'`;

默认事件 -> 阻止默认事件  -> JS原生：`$event.preventDefault()` ; -> Vue简写: `@click.prevent='func'`;

键盘事件 -> JS键码获取keyCode -> $event.keyCode ; 


## computed 与 watch使用与区别

推荐大部分使用computed，调用ajax、新旧值比较时使用watch；

```
// computed页面加载时触发或关联数据改变时触发
// 基于data中数据生成新的变量，例子：根据i获得num
computed:{
    num : function(val){
        return this.i * 2 ;   //必须要return返回；
    }
},

// 基于当前data进行变化，例子：根据i二变化
watch:{
    i:{
        deep：true,    //深度监听，一般用于json属性某值改变
        handler:function(newVal,oldVal){
            console.log(newVal,oldVal)
        }
    }
}
```

## 生命周期 (总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后)

由于vue是写在onload中所以不存在jquery的onready & onload说法，但是还是vue自身的加载顺序，一般文档时就载入用黑下划线的事件；
    
推荐参考：https://segmentfault.com/a/1190000008010666 
    
* `beforecreated` element、data 并未初始化 ；
    
* `created` data 已初始化，element并没，用于新增数据；
    
* `beforeMount` 完成了element、data 初始化 ；
    
* `mounted` 后端返回数据配合路由钩子处理虚拟DOM；
    
* `beforeDestory` 删除组件前；

![](/img/pubilc/vue-lifeCycle.jpg)

## 获取API：

* axios默认不启用跨域异步访问（Access-Control-Allow-Origin），需要服务器（后端）开启才能使用；


* 封装Axios全局使用：

```
import Vue from 'vue'
import {Message, Loading} from 'element-ui'
import axios from 'axios'
Vue.component(Message)
Vue.prototype.$message = Message

// TOKEN验证需要在headers设置
let http = axios.create({
  baseURL: process.env.API_ROOT,
  headers: {'app_token': localStorage.getItem('app_token') ? localStorage.getItem('app_token') : getCookie('sst-vue-po-sessionId')}
})

function _h(method) {
  return (resPath, params, loading = false, headers = {'Content-Type': 'application/json;charset=UTF-8'}) => {
    let result = {
      code: 0,
      message: '',
      data: {},
      error: null,
      exception: null
    }
    let loadingInstance = loading ?  Vue.prototype.$loading({
      lock: true,
      text: 'loading ...',
      fullscreen: true
    }) : null;

    return http[method](resPath, params, headers)
      .then(response => {
        result.code = response.data.code
        result.data = response.data.data
        result.message = response.data.message
        loadingInstance && loadingInstance.close()
        if (response.data.code === '200') {
          return Promise.resolve(result)
        } else if (response.data.code === '507') {
          Vue.prototype.$message && Vue.prototype.$message.error(result.message) // 全局返回错误信息（下面雷同）
          top.location.href = process.env.LOGIN_URL
        }
        else {
          loadingInstance && loadingInstance.close()
          Vue.prototype.$message && Vue.prototype.$message.error(result.message)
          result.error = true
          return Promise.resolve(result)
        }
      })
      .catch(error => {
        console.log('request error:', error)

        result.error = error || new Error('request error')
        result.exception = error.exception || null
        result.message = error.message || 'request error'
        result.code = error.status

        Vue.prototype.$message && Vue.prototype.$message.error(result.message)
        return Promise.resolve(result)
      })
  }
}

function getCookie(cname) {
  var name = cname + "=";
  var ca = document.cookie.split(';');
  for (var i = 0; i < ca.length; i++) {
    var c = ca[i];
    console.log(c)
    while (c.charAt(0) == ' ') c = c.substring(1);
    if (c.indexOf(name) != -1) {
      return c.substring(name.length, c.length);
    }
  }
  return "";
}

export default {
  get: _h('get'),
  post: _h('post'),
  delete: _h('delete')
}

```
